### 第三章
### 基本类型
基本数据类型:Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问 的，因为可以操作保存在变量中的实际的值。
### 引用类型
引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置， 也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 为此，引用类型的值是按引用访问的。

### 什么是变量对象？

我们在写程序的时候会定义很多变量和函数，而上面的问题的本质实际是对于解释器来说，是如何以及从哪里找到这些变量和函数的？

变量对象是与执行上下文对应的概念，定义着执行上下文下的所有变量、函数以及当前执行上下文函数的参数列表。也就是说变量对象定义着一个函数内定义的参数列表、内部变量和内部函数。

### 什么是活动对象？
 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。所以活动对象实际就是变量对象在真正执行时的另一种形式。

 ### 全局变量对象
  我们上面说的都是函数上下文中的变量对象，是根据执行上下文中的数据(参数、变量、函数)确定其内容的，全局上下文中的变量对象则有所不同。以浏览器为例，全局变量对象是window对象，全局上下文在执行前的初始化阶段，全局变量、函数都是被挂载倒window上的。

### 第四章
### 参数传递  可以把 ECMAScript 函数的参数想象成局部变量
function setName(obj) { obj.name = "Nicholas"; obj = new Object(); obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"

这个例子，就是在 setName()函数中添加了两行代码:一行代码为 obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。在把 person 传递给 setName()后，其 name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量 obj，同时将其 name 属性设置为"Greg"。如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值 为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。这说明 即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
 
### 执行环境及作用域

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流 正是由这个方便的机制控制着。 5
当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对 6 象在最开始时只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。作用域链中 的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。

### 基本类型与引用类型的区别
基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中;

从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本;

引用类型的值是对象，保存在堆内存中;

包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;

从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同
一个对象;

### 第五章 引用类型

### 栈方法
ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表 现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO(Last-In-First-Out， 后进先出)的数据结构，也就是最新添加的项最早被移除。而栈中项的插入(叫做推入)和移除(叫做 弹出)，只发生在一个位置——栈的顶部。ECMAScript 为数组专门提供了 push()和 pop()方法，以便 实现类似栈的行为。

push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后~~~数组的长度。

而 pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回 ~~~ 移除的项。

### 队列方法

栈数据结构的访问规则是 LIFO(后进先出)，而队列数据结构的访问规则是 FIFO(First-In-First-Out， 先进先出)。队列在列表的末端添加项，从列表的前端移除项。由于 push()是向数组末端添加项的方法， 因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移除数组中的第一个项并返回~~~该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使 用队列一样使用数组。

数组提供了一个 unshift()方法。顾名思义，unshift()与 shift()的用途相反: 它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 unshift()和 pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项

### 重排序方法
数组中已经存在两个可以直接用来重排序的方法:reverse()和 sort()。

###  操作方法
slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以 接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该 参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项— —但不包括结束位置的项。注意，slice()方法不会影响原始数组。请看下面的例子。
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2);   //green,blue,yellow,purple
alert(colors3);   //green,blue,yellow

concat()   arr1.concat('aaa','bbb') ||  arr1.concat(["aaa","bbb"])

splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。 splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。
### 删除:
可以删除任意数量的项，只需指定 2 个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项。
### 插入:
可以向指定位置插入任意数量的项，只需提供 3 个参数:起始位置、0(要删除的项数) 和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如， splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。

###替换:
可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 "red"和"green"。
splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)。下面的代码展示了上述 3 种使用 splice()方法的方式。

 var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1); alert(colors); // green,blue alert(removed); // red，返回的数组中只包含一项
removed = colors.splice(1, 0, "yellow", "orange"); alert(colors); // green,yellow,orange,blue alert(removed); // 返回的是一个空数组
removed = colors.splice(1, 1, "red", "purple"); alert(colors); // green,red,purple,orange,blue alert(removed); // yellow，返回的数组中只包含一项
// 删除第一项
// 从位置 1 开始插入两项
// 插入两项，删除一项
  